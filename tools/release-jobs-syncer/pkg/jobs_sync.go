/*
Copyright 2022 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pkg

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"

	"istio.io/test-infra/tools/prowgen/pkg/spec"
	"k8s.io/apimachinery/pkg/util/sets"
	"sigs.k8s.io/yaml"
)

const (
	fileHeader = `# #############################################################################
# ####                                                                     ####
# ####     THIS FILE IS AUTOMATICALLY GENERATED by release-jobs-syncer.    ####
# ####        PLEASE ONLY MODIFY IT MANUALLY WHEN ACTUALLY NEEDED.         ####
# ####                                                                     ####
# #############################################################################
`
)

// extraPeriodicProwJobsToSync contains the extra periodic Prow jobs to sync for
// each repo.
// By default only the continuous Prow jobs will be synced in order to reduce
// the load with Prow.
var extraPeriodicProwJobsToSync map[string]sets.String = map[string]sets.String{
	"knative/serving":  sets.NewString("s390x-kourier-tests", "s390x-contour-tests", "ppc64le-kourier-tests", "ppc64le-contour-tests"),
	"knative/eventing": sets.NewString("s390x-e2e-tests", "s390x-e2e-reconciler-tests", "ppc64le-e2e-tests", "ppc64le-e2e-reconciler-tests"),
	"knative/client":   sets.NewString("s390x-e2e-tests", "ppc64le-e2e-tests"),
	"knative/operator": sets.NewString("s390x-e2e-tests", "ppc64le-e2e-tests"),
}

func syncProwJobsForRelease(configRootPath, org, repo, releaseToRemove, releaseToAdd string) error {
	mainPJConfigPath := filepath.Join(configRootPath, org, repo+".yaml")
	mainJobsConfig := mustReadJobsConfig(mainPJConfigPath)
	if !hasReleaseProwJob(mainJobsConfig) {
		log.Printf("Skip syncing for %s/%s since no release Prow job has been configured.", org, repo)
		return nil
	}

	if releaseToRemove != "" {
		filePathToRemove := filepath.Join(configRootPath, org, fmt.Sprintf("%s-%s.yaml", repo, releaseToRemove))
		log.Printf("Removing config file %q", filePathToRemove)
		if err := os.Remove(filePathToRemove); err != nil {
			return fmt.Errorf("error deleting file %q: %w", filePathToRemove, err)
		}
	}

	if releaseToAdd != "" {
		filePathToAdd := filepath.Join(configRootPath, org, fmt.Sprintf("%s-%s.yaml", repo, releaseToAdd))

		// Load the main Prow jobs config everytime to simulate a deepcopy.
		releaseJobsConfig := mustReadJobsConfig(mainPJConfigPath)
		releaseJobsConfig.Branches = []string{releaseToAdd}
		updatedJobs := []spec.Job{}
		for _, job := range releaseJobsConfig.Jobs {
			// "nightly" Prow job is only for the main branch so skip syncing it
			if job.Name == "nightly" {
				continue
			}

			// Check if the periodic Prow job needs to be synced.
			if hasPeriodicType(job.Types) {
				orgRepo := org + "/" + repo
				extra, extraExists := extraPeriodicProwJobsToSync[orgRepo]
				// Do not sync the periodic Prow job, if:
				// it's not a common Prow job that needs to be synced
				// AND
				// it's not one of the extra Prow jobs that has been configured
				if (job.Name != "continuous" && job.Name != "release") && (!extraExists || !extra.Has(job.Name)) {
					continue
				}
			}

			// Release branches need dot-release Prow jobs with different
			// args.
			// Modify its command args based on the auto-release Prow job.
			if job.Name == "release" {
				commandArgs := []string{}
				for _, arg := range append(job.Command, job.Args...) {
					if arg == "--auto-release" {
						commandArgs = append(commandArgs, "--dot-release")
					} else {
						commandArgs = append(commandArgs, arg)
					}
				}
				commandArgs = append(commandArgs, "--branch", releaseToAdd)
				job.Command = commandArgs
				job.Args = nil
			}
			updatedJobs = append(updatedJobs, job)
		}
		releaseJobsConfig.Jobs = updatedJobs

		bs, _ := yaml.Marshal(releaseJobsConfig)
		bs = append([]byte(fileHeader), bs...)
		log.Printf("Adding config file %q", filePathToAdd)
		ioutil.WriteFile(filePathToAdd, bs, 0o644)
	}

	return nil
}

func hasReleaseProwJob(jobsConfig spec.JobsConfig) bool {
	for _, job := range jobsConfig.Jobs {
		if job.Name == "release" {
			return true
		}
	}
	return false
}

func hasPeriodicType(pjTypes []string) bool {
	for _, tp := range pjTypes {
		if tp == "periodic" {
			return true
		}
	}
	return false
}
