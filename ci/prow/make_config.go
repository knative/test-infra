/*
Copyright 2019 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// The make_config tool generates a full Prow config for the Knative project,
// with input from a yaml file with key definitions.

package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"math"
	"os"
	"path"
	"regexp"
	"strings"
	"time"

	yaml "gopkg.in/yaml.v2"
	"knative.dev/test-infra/ci/prow/configlib"
	"knative.dev/test-infra/shared/common"
)

const (
	// Manifests generated by ko are indented by 2 spaces.
	baseIndent  = "  "
	templateDir = "templates"

	// ##########################################################
	// ############## prow configuration templates ##############
	// ##########################################################
	// generalProwConfig contains config-wide definitions.
	generalProwConfig = "prow_config_header.yaml"

	// presubmitJob is the template for presubmit jobs.
	presubmitJob = "prow_presubmit_job.yaml"

	// presubmitGoCoverageJob is the template for go coverage presubmit jobs.
	presubmitGoCoverageJob = "prow_presubmit_gocoverate_job.yaml"

	// goCoveragePostsubmitJob is the template for the go postsubmit coverage job.
	goCoveragePostsubmitJob = "prow_postsubmit_gocoverage_job.yaml"
)

// repositoryData contains basic data about each Knative repository.
type repositoryData struct {
	Name                string
	EnableGoCoverage    bool
	GoCoverageThreshold int
	Processed           bool
	DotDev              bool
	LegacyBranches      []string
}

// ####################################################################################################
// ################ data definitions that are used for the prow config file generation ################
// ####################################################################################################

// sectionGenerator is a function that generates Prow job configs given a slice of a yaml file with configs.
type sectionGenerator func(string, string, yaml.MapSlice)

// newJobNeeded is a function that determined if we need to add a new job for this repository.
type newJobNeeded func(repositoryData) bool

// stringArrayFlag is the content of a multi-value flag.
type stringArrayFlag []string

var (
	// Values used in the jobs that can be changed through command-line flags.
	output                       *os.File
	gcsBucket                    string
	logsDir                      string
	presubmitLogsDir             string
	testAccount                  string
	nightlyAccount               string
	releaseAccount               string
	flakesreporterDockerImage    string
	prowversionbumperDockerImage string
	githubCommenterDockerImage   string
	coverageDockerImage          string
	prowTestsDockerImage         string
	presubmitScript              string
	releaseScript                string
	performanceScript            string
	webhookAPICoverageScript     string
	cleanupScript                string

	// #########################################################################
	// ############## data used for generating prow configuration ##############
	// #########################################################################
	// Array constants used throughout the jobs.
	allPresubmitTests = []string{"--all-tests", "--emit-metrics"}
	releaseNightly    = []string{"--publish", "--tag-release"}
	releaseLocal      = []string{"--nopublish", "--notag-release"}

	// Overrides and behavior changes through command-line flags.
	repositoryOverride string
	jobNameFilter      string
	preCommand         string
	extraEnvVars       stringArrayFlag
	timeoutOverride    int

	// List of Knative repositories.
	repositories []repositoryData

	// Map which sections of the config.yaml were written to stdout.
	sectionMap map[string]bool

	// The template evaluator used to expand prow job config template variables
	tmplEval = configlib.NewTemplateEvaluator(output, gitHubRepo)
)

// Generate cron string based on job type, offset generated from jobname
// instead of assign random value to ensure consistency among runs,
// timeout is used for determining how many hours apart
func generateCron(jobType, jobName string, timeout int) string {
	getUTCtime := func(i int) int { return i + 7 }
	// Sums the ascii valus of all letters in a jobname,
	// this value is used for deriving offset after hour
	var sum float64
	for _, c := range jobType + jobName {
		sum += float64(c)
	}
	// Divide 60 minutes into 6 buckets
	bucket := int(math.Mod(sum, 6))
	// Offset in bucket, range from 0-9, first mod with 11(a random prime number)
	// to ensure every digit has a chance (i.e., if bucket is 0, sum has to be multiply of 6,
	// so mod by 10 can only return even number)
	offsetInBucket := int(math.Mod(math.Mod(sum, 11), 10))
	minutesOffset := bucket*10 + offsetInBucket
	// Determines hourly job inteval based on timeout
	hours := int((timeout+5)/60) + 1 // Allow at least 5 minutes between runs
	hourCron := fmt.Sprintf("%d * * * *", minutesOffset)
	if hours > 1 {
		hourCron = fmt.Sprintf("%d */%d * * *", minutesOffset, hours)
	}
	dayCron := fmt.Sprintf("%d %%d * * *", minutesOffset)    // hour
	weekCron := fmt.Sprintf("%d %%d * * %%d", minutesOffset) // hour, weekday

	var res string
	switch jobType {
	case "continuous", "custom-job", "auto-release": // Every hour
		res = fmt.Sprintf(hourCron)
	case "branch-ci": // Every day 1-2 PST
		res = fmt.Sprintf(dayCron, getUTCtime(1))
	case "nightly": // Every day 2-3 PST
		res = fmt.Sprintf(dayCron, getUTCtime(2))
	case "dot-release": // Every Tuesday 2-3 PST
		res = fmt.Sprintf(weekCron, getUTCtime(2), 2)
	case "latency": // Every day 1-2 PST
		res = fmt.Sprintf(dayCron, getUTCtime(1))
	case "performance": // Every day 1-2 PST
		res = fmt.Sprintf(dayCron, getUTCtime(1))
	case "performance-mesh": // Every day 3-4 PST
		res = fmt.Sprintf(dayCron, getUTCtime(3))
	case "webhook-apicoverage": // Every day 2-3 PST
		res = fmt.Sprintf(dayCron, getUTCtime(2))
	default:
		log.Printf("job type not supported for cron generation '%s'", jobName)
	}
	return res
}

// Yaml parsing helpers.

// read template yaml file content
func readTemplate(fp string) string {
	if _, ok := templatesCache[fp]; !ok {
		content, err := ioutil.ReadFile(path.Join(templateDir, fp))
		if nil != err {
			log.Fatalf("Failed read file '%s': '%v'", fp, err)
		}
		templatesCache[fp] = string(content)
	}
	return templatesCache[fp]
}

func combineSlices(a1 []string, a2 []string) []string {
	var res []string
	res = append(res, a1...)
	for _, e2 := range a2 {
		add := true
		for _, e1 := range a1 {
			if e1 == e2 {
				add = false
			}
		}
		if add {
			res = append(res, e2)
		}
	}
	return res
}

// Consolidate whitelisted and skipped branches with newly added whitelisted/skipped
func consolidateBranches(whitelisted []string, skipped []string, newWhitelisted []string, newSkipped []string) ([]string, []string) {
	// Merge the whitelisted and newWhitelisted arrays, ignoring any element present in skipped or newSkipped.
	var combinedWhitelisted []string
	var combinedSkipped []string
	combinedWhitelisted = combineSlices(whitelisted, newWhitelisted)
	combinedSkipped = combineSlices(skipped, newSkipped)
	if len(combinedWhitelisted) > 0 {
		var tmp []string
		for _, elem := range combinedWhitelisted {
			add := true
			for _, skip := range combinedSkipped {
				if elem == skip {
					add = false
				}
			}
			if add {
				tmp = append(tmp, elem)
			}
		}
		combinedWhitelisted = tmp
		combinedSkipped = make([]string, 0)
	}
	return combinedWhitelisted, combinedSkipped
}

// Config generation functions.

// newbaseProwJobTemplateData returns a BaseProwJobTemplateData type with its initial, default values.
func newbaseProwJobTemplateData(repo string) configlib.BaseProwJobTemplateData {
	var data configlib.BaseProwJobTemplateData
	data.Timeout = 50
	data.OrgName = strings.Split(repo, "/")[0]
	data.RepoName = strings.Replace(repo, data.OrgName+"/", "", 1)
	data.RepoNameForJob = strings.ToLower(strings.Replace(repo, "/", "-", -1))
	data.RepoBranch = "master" // Default to be master, will override later for other branches
	data.GcsBucket = gcsBucket
	data.RepoURI = "github.com/" + repo
	data.CloneURI = fmt.Sprintf("\"https://%s.git\"", data.RepoURI)
	data.GcsLogDir = fmt.Sprintf("gs://%s/%s", gcsBucket, logsDir)
	data.GcsPresubmitLogDir = fmt.Sprintf("gs://%s/%s", gcsBucket, presubmitLogsDir)
	data.Year = time.Now().Year()
	data.PresubmitLogsDir = presubmitLogsDir
	data.LogsDir = logsDir
	data.ReleaseGcs = strings.Replace(repo, data.OrgName+"/", "knative-releases/", 1)
	data.AlwaysRun = true
	data.Image = prowTestsDockerImage
	data.ServiceAccount = testAccount
	data.Command = ""
	data.Args = make([]string, 0)
	data.Volumes = make([]string, 0)
	data.VolumeMounts = make([]string, 0)
	data.Env = make([]string, 0)
	data.ExtraRefs = []string{"- org: " + data.OrgName, "  repo: " + data.RepoName}
	data.Labels = make([]string, 0)
	data.Optional = ""
	return data
}

// General helpers.

// createCommand returns an array with the command to run and its arguments.
func createCommand(data configlib.BaseProwJobTemplateData) []string {
	c := []string{data.Command}
	// Prefix the pre-command if present.
	if preCommand != "" {
		c = append([]string{preCommand}, c...)
	}
	return append(c, data.Args...)
}

// addPubsubLabelsToJob adds the pubsub labels so the prow job message will be picked up by test-infra monitoring
func addMonitoringPubsubLabelsToJob(data *configlib.BaseProwJobTemplateData, runID string) {
	configlib.AddLabelToJob(data, "prow.k8s.io/pubsub.project", "knative-tests")
	configlib.AddLabelToJob(data, "prow.k8s.io/pubsub.topic", "knative-monitoring")
	configlib.AddLabelToJob(data, "prow.k8s.io/pubsub.runID", runID)
}

// setupDockerInDockerForJob enables docker-in-docker for the given job.
func setupDockerInDockerForJob(data *configlib.BaseProwJobTemplateData) {
	configlib.AddVolumeToJob(data, "/docker-graph", "docker-graph", false, "")
	configlib.AddEnvToJob(data, "DOCKER_IN_DOCKER_ENABLED", "\"true\"")
	(*data).SecurityContext = []string{"privileged: true"}
}

// Config parsers.

// parseBasicJobConfigOverrides updates the given BaseProwJobTemplateData with any base option present in the given config.
func parseBasicJobConfigOverrides(data *configlib.BaseProwJobTemplateData, config yaml.MapSlice) {
	(*data).ExtraRefs = append((*data).ExtraRefs, "  base_ref: "+(*data).RepoBranch)
	for i, item := range config {
		switch item.Key {
		case "skip_branches":
			(*data).SkipBranches = common.GetStringArray(item.Value)
		case "branches":
			(*data).Branches = common.GetStringArray(item.Value)
		case "args":
			(*data).Args = common.GetStringArray(item.Value)
		case "timeout":
			(*data).Timeout = common.GetInt(item.Value)
		case "command":
			(*data).Command = common.GetString(item.Value)
		case "full-command":
			parts := strings.Split(common.GetString(item.Value), " ")
			(*data).Command = parts[0]
			(*data).Args = parts[1:]
		case "needs-dind":
			if common.GetBool(item.Value) {
				setupDockerInDockerForJob(data)
			}
		case "always_run":
			(*data).AlwaysRun = common.GetBool(item.Value)
		case "dot-dev":
			for i, repo := range repositories {
				if path.Base(repo.Name) == (*data).RepoName {
					repositories[i].DotDev = true
				}
			}
		case "legacy-branches":
			for i, repo := range repositories {
				if path.Base(repo.Name) == (*data).RepoName {
					repositories[i].LegacyBranches = common.GetStringArray(item.Value)
				}
			}
		case "env-vars":
			configlib.AddExtraEnvVarsToJob(data, common.GetStringArray(item.Value))
		case "optional":
			(*data).Optional = "optional: true"
		case nil: // already processed
			continue
		default:
			log.Fatalf("Unknown entry %q for job", item.Key)
			continue
		}
		// Knock-out the item, signalling it was already parsed.
		config[i] = yaml.MapItem{}
	}
	// Add repo path alias to job for vanity import URLs if dot-dev setting is true (and this is not a legacy branch)
	for _, repo := range repositories {
		if path.Base(repo.Name) == (*data).RepoName && repo.DotDev {
			needPathAlias := true
			for _, branchName := range repo.LegacyBranches {
				if branchName == (*data).RepoBranch {
					needPathAlias = false
				}
			}
			if needPathAlias {
				(*data).PathAlias = "path_alias: knative.dev/" + (*data).RepoName
				(*data).ExtraRefs = append((*data).ExtraRefs, "  "+(*data).PathAlias)
			}
			break
		}
	}
	// Override any values if provided by command-line flags.
	if timeoutOverride > 0 {
		(*data).Timeout = timeoutOverride
	}
}

// generatePresubmit generates all presubmit job configs for the given repo and configuration.
func generatePresubmit(title string, repoName string, presubmitConfig yaml.MapSlice) {
	var data configlib.PresubmitJobTemplateData
	data.Base = newbaseProwJobTemplateData(repoName)
	data.Base.Command = presubmitScript
	data.Base.GoCoverageThreshold = 50
	jobTemplate := readTemplate(presubmitJob)
	repoData := repositoryData{Name: repoName, EnableGoCoverage: false, GoCoverageThreshold: data.Base.GoCoverageThreshold}
	isMonitoredJob := false
	generateJob := true
	for i, item := range presubmitConfig {
		switch item.Key {
		case "build-tests", "unit-tests", "integration-tests":
			if !common.GetBool(item.Value) {
				return
			}
			jobName := common.GetString(item.Key)
			data.PresubmitJobName = data.Base.RepoNameForJob + "-" + jobName
			// Use default arguments if none given.
			if len(data.Base.Args) == 0 {
				data.Base.Args = []string{"--" + jobName}
			}
			if item.Key == "integration-tests" {
				isMonitoredJob = true
			}
		case "go-coverage":
			if !common.GetBool(item.Value) {
				return
			}
			jobTemplate = readTemplate(presubmitGoCoverageJob)
			data.PresubmitJobName = data.Base.RepoNameForJob + "-go-coverage"
			data.Base.Image = coverageDockerImage
			data.Base.ServiceAccount = ""
			repoData.EnableGoCoverage = true
			configlib.AddVolumeToJob(&data.Base, "/etc/covbot-token", "covbot-token", true, "")
		case "custom-test":
			data.PresubmitJobName = data.Base.RepoNameForJob + "-" + common.GetString(item.Value)
		case "go-coverage-threshold":
			data.Base.GoCoverageThreshold = common.GetInt(item.Value)
			repoData.GoCoverageThreshold = data.Base.GoCoverageThreshold
		case "repo-settings":
			generateJob = false
		default:
			continue
		}
		// Knock-out the item, signalling it was already parsed.
		presubmitConfig[i] = yaml.MapItem{}
	}
	repositories = append(repositories, repoData)
	parseBasicJobConfigOverrides(&data.Base, presubmitConfig)
	if !generateJob {
		return
	}
	data.PresubmitCommand = createCommand(data.Base)
	data.PresubmitPullJobName = "pull-" + data.PresubmitJobName
	data.PresubmitPostJobName = "post-" + data.PresubmitJobName
	if data.Base.ServiceAccount != "" {
		configlib.AddEnvToJob(&data.Base, "GOOGLE_APPLICATION_CREDENTIALS", data.Base.ServiceAccount)
		configlib.AddEnvToJob(&data.Base, "E2E_CLUSTER_REGION", "us-central1")
	}
	if isMonitoredJob {
		addMonitoringPubsubLabelsToJob(&data.Base, data.PresubmitPullJobName)
	}
	configlib.AddExtraEnvVarsToJob(&data.Base, extraEnvVars)
	configlib.ConfigureServiceAccountForJob(&data.Base)
	jobName := data.PresubmitPullJobName
	executeJobTemplateWrapper(repoName, &data, func(data interface{}) {
		executeJobTemplate("presubmit", jobTemplate, title, repoName, jobName, true, data)
	})
	// TODO(adrcunha): remove once the coverage-dev job isn't necessary anymore.
	// Generate config for pull-knative-serving-go-coverage-dev right after pull-knative-serving-go-coverage
	if data.PresubmitPullJobName == "pull-knative-serving-go-coverage" {
		data.PresubmitPullJobName += "-dev"
		data.Base.AlwaysRun = false
		data.Base.Image = strings.Replace(data.Base.Image, "coverage:latest", "coverage-dev:latest-dev", -1)
		template := strings.Replace(readTemplate(presubmitGoCoverageJob), "(all|", "(", 1)
		executeJobTemplate("presubmit", template, title, repoName, data.PresubmitPullJobName, true, data)
	}
}

// generateGoCoveragePostsubmit generates the go coverage postsubmit job config for the given repo.
func generateGoCoveragePostsubmit(title, repoName string, _ yaml.MapSlice) {
	var data configlib.PostsubmitJobTemplateData
	data.Base = newbaseProwJobTemplateData(repoName)
	data.Base.Image = coverageDockerImage
	data.PostsubmitJobName = fmt.Sprintf("post-%s-go-coverage", data.Base.RepoNameForJob)
	for _, repo := range repositories {
		if repo.Name == repoName && repo.DotDev {
			data.Base.PathAlias = "path_alias: knative.dev/" + path.Base(repoName)
		}
	}
	configlib.AddExtraEnvVarsToJob(&data.Base, extraEnvVars)
	configlib.ConfigureServiceAccountForJob(&data.Base)
	jobName := data.PostsubmitJobName
	executeJobTemplateWrapper(repoName, &data, func(data interface{}) {
		executeJobTemplate("postsubmit go coverage", readTemplate(goCoveragePostsubmitJob), "postsubmits", repoName, jobName, true, data)
	})
	// TODO(adrcunha): remove once the coverage-dev job isn't necessary anymore.
	// Generate config for post-knative-serving-go-coverage-dev right after post-knative-serving-go-coverage
	if data.PostsubmitJobName == "post-knative-serving-go-coverage" {
		data.PostsubmitJobName += "-dev"
		data.Base.Image = strings.Replace(data.Base.Image, "coverage:latest", "coverage-dev:latest-dev", -1)
		executeJobTemplate("presubmit", readTemplate(goCoveragePostsubmitJob), "postsubmits", repoName, data.PostsubmitJobName, false, data)
	}
}

// parseSection generate the configs from a given section of the input yaml file.
func parseSection(config yaml.MapSlice, title string, generate sectionGenerator, finalize sectionGenerator) {
	for _, section := range config {
		if section.Key != title {
			continue
		}
		for _, repo := range common.GetMapSlice(section.Value) {
			repoName := common.GetString(repo.Key)
			for _, jobConfig := range common.GetInterfaceArray(repo.Value) {
				generate(title, repoName, common.GetMapSlice(jobConfig))
			}
			if finalize != nil {
				finalize(title, repoName, nil)
			}
		}
	}
}

// generateOtherJobConfigs generates job config with the generator if new job is required for it.
func generateOtherJobConfigs(title string, newJobNeeded newJobNeeded, generate sectionGenerator) {
	for i := range repositories { // Keep order for predictable output.
		if !newJobNeeded(repositories[i]) {
			continue
		}
		generate(title, repositories[i].Name, nil)
	}
}

// Template helpers.

// gitHubRepo returns the correct reference for the GitHub repository.
func gitHubRepo(data configlib.BaseProwJobTemplateData) string {
	if repositoryOverride != "" {
		return repositoryOverride
	}
	s := data.RepoURI
	if data.RepoBranch != "" {
		s += "=" + data.RepoBranch
	}
	return s
}

// outputConfig outputs the given line, if not empty, to stdout.
func outputConfig(line string) {
	if strings.TrimSpace(line) != "" {
		fmt.Fprintln(output, line)
	}
}

// executeJobTemplateWrapper takes in consideration of repo settings, decides how many variants of the
// same job needs to be generated and generates them.
func executeJobTemplateWrapper(repoName string, data interface{}, generateOneJob func(data interface{})) {
	var legacyBranches []string
	// Find out if LegacyBranches is set in repo settings
	for _, repo := range repositories {
		if repo.Name == repoName {
			if len(repo.LegacyBranches) > 0 {
				legacyBranches = repo.LegacyBranches
			}
		}
	}
	if len(legacyBranches) == 0 { // Generate only one job as normal if LegacyBranches is not set
		generateOneJob(data)
	} else {
		// Generate one job with 'knative.dev' path alias for branches other than legacy branches,
		// and another job without path alias for legacy branches
		var base *configlib.BaseProwJobTemplateData
		switch v := data.(type) {
		case *configlib.PresubmitJobTemplateData:
			base = &data.(*configlib.PresubmitJobTemplateData).Base
		case *configlib.PostsubmitJobTemplateData:
			if strings.HasSuffix(data.(*configlib.PostsubmitJobTemplateData).PostsubmitJobName, "go-coverage") {
				generateOneJob(data)
				return
			}
			base = &data.(*configlib.PostsubmitJobTemplateData).Base
		default:
			log.Fatalf("Unrecognized job template type: '%v'", v)
		}
		branches := base.Branches
		skipBranches := base.SkipBranches
		base.PathAlias = ""
		base.Branches, base.SkipBranches = consolidateBranches(branches, skipBranches, legacyBranches, make([]string, 0))
		generateOneJob(data)
		base.Branches, base.SkipBranches = consolidateBranches(branches, skipBranches, make([]string, 0), legacyBranches)
		base.PathAlias = "path_alias: knative.dev/" + base.RepoName
		base.ExtraRefs = append(base.ExtraRefs, "  "+base.PathAlias)
		generateOneJob(data)
	}
}

// executeTemplate outputs the given job template with the given data, respecting any filtering.
func executeJobTemplate(name, templ, title, repoName, jobName string, groupByRepo bool, data interface{}) {
	if jobNameFilter != "" && jobNameFilter != jobName {
		return
	}
	if !sectionMap[title] {
		outputConfig(title + ":")
		sectionMap[title] = true
	}
	if groupByRepo {
		if !sectionMap[title+repoName] {
			outputConfig(baseIndent + repoName + ":")
			sectionMap[title+repoName] = true
		}
	}
	tmplEval.ExecuteTemplate(name, templ, data)
}

// Multi-value flag parser.

func (a *stringArrayFlag) String() string {
	return strings.Join(*a, ", ")
}

func (a *stringArrayFlag) Set(value string) error {
	*a = append(*a, value)
	return nil
}

// parseJob gets the job data from the original yaml data, now the jobName can be "presubmits" or "periodic"
func parseJob(config yaml.MapSlice, jobName string) yaml.MapSlice {
	for _, section := range config {
		if section.Key == jobName {
			return common.GetMapSlice(section.Value)
		}
	}

	log.Fatalf("The metadata misses %s configuration, cannot continue.", jobName)
	return nil
}

// parseGoCoverageMap constructs a map, indicating which repo is enabled for go coverage check
func parseGoCoverageMap(presubmitJob yaml.MapSlice) map[string]bool {
	goCoverageMap := make(map[string]bool)
	for _, repo := range presubmitJob {
		repoName := strings.Split(common.GetString(repo.Key), "/")[1]
		goCoverageMap[repoName] = false
		for _, jobConfig := range common.GetInterfaceArray(repo.Value) {
			for _, item := range common.GetMapSlice(jobConfig) {
				if item.Key == "go-coverage" {
					goCoverageMap[repoName] = common.GetBool(item.Value)
					break
				}
			}
		}
	}

	return goCoverageMap
}

// collectMetaData collects the meta data from the original yaml data, which can be then used for building the test groups and dashboards config
func collectMetaData(periodicJob yaml.MapSlice) {
	for _, repo := range periodicJob {
		rawName := common.GetString(repo.Key)
		projName := strings.Split(rawName, "/")[0]
		repoName := strings.Split(rawName, "/")[1]
		jobDetailMap := addProjAndRepoIfNeed(projName, repoName)

		// parse job configs
		for _, conf := range common.GetInterfaceArray(repo.Value) {
			jobDetailMap = metaData[projName]
			jobConfig := common.GetMapSlice(conf)
			enabled := false
			jobName := ""
			releaseVersion := ""
			for _, item := range jobConfig {
				switch item.Key {
				case "continuous", "dot-release", "auto-release", "performance", "performance-mesh", "latency", "nightly":
					if common.GetBool(item.Value) {
						enabled = true
						jobName = common.GetString(item.Key)
					}
				case "branch-ci":
					enabled = common.GetBool(item.Value)
					jobName = "continuous"
				case "release":
					releaseVersion = common.GetString(item.Value)
				case "custom-job":
					enabled = true
					jobName = common.GetString(item.Value)
				default:
					// continue here since we do not need to care about other entries, like cron, command, etc.
					continue
				}
			}
			// add job types for the corresponding repos, if needed
			if enabled {
				// if it's a job for a release branch
				if releaseVersion != "" {
					releaseProjName := fmt.Sprintf("%s-%s", projName, releaseVersion)
					jobDetailMap = addProjAndRepoIfNeed(releaseProjName, repoName)
				}
				newJobTypes := append(jobDetailMap[repoName], jobName)
				jobDetailMap[repoName] = newJobTypes
			}
		}
		addTestCoverageJobIfNeeded(&jobDetailMap, repoName)
	}

	// add test coverage jobs for the repos that haven't been handled
	addRemainingTestCoverageJobs()
}

// addProjAndRepoIfNeed adds the project and repo if they are new in the metaData map, then return the jobDetailMap
func addProjAndRepoIfNeed(projName string, repoName string) map[string][]string {
	// add project in the metaData
	if _, exists := metaData[projName]; !exists {
		metaData[projName] = make(map[string][]string)
		if !common.StrExists(projNames, projName) {
			projNames = append(projNames, projName)
		}
	}

	// add repo in the project
	jobDetailMap := metaData[projName]
	if _, exists := jobDetailMap[repoName]; !exists {
		if !common.StrExists(repoNames, repoName) {
			repoNames = append(repoNames, repoName)
		}
		jobDetailMap[repoName] = make([]string, 0)
	}
	return jobDetailMap
}

// addTestCoverageJobIfNeeded adds test-coverage job for the repo if it has go coverage check
func addTestCoverageJobIfNeeded(jobDetailMap *map[string][]string, repoName string) {
	if goCoverageMap[repoName] {
		newJobTypes := append((*jobDetailMap)[repoName], "test-coverage")
		(*jobDetailMap)[repoName] = newJobTypes
		// delete this repoName from the goCoverageMap to avoid it being processed again when we
		// call the function addRemainingTestCoverageJobs
		delete(goCoverageMap, repoName)
	}
}

// addRemainingTestCoverageJobs adds test-coverage jobs for the repos that haven't been processed.
func addRemainingTestCoverageJobs() {
	// handle repos that only have go coverage
	for repoName, hasGoCoverage := range goCoverageMap {
		if hasGoCoverage {
			jobDetailMap := addProjAndRepoIfNeed(projNames[0], repoName)
			jobDetailMap[repoName] = []string{"test-coverage"}
		}
	}
}

// buildProjRepoStr builds the projRepoStr used in the config file with projName and repoName
func buildProjRepoStr(projName string, repoName string) string {
	projVersion := ""
	if strings.Contains(projName, "-") {
		projNameAndVersion := strings.Split(projName, "-")
		projName = projNameAndVersion[0]
		projVersion = projNameAndVersion[1]
	}
	projRepoStr := repoName
	if projVersion != "" {
		projRepoStr += ("-" + projVersion)
	}
	projRepoStr = projName + "-" + projRepoStr
	return strings.ToLower(projRepoStr)
}

// isReleased returns true for project name that has version
func isReleased(projName string) bool {
	return regexp.MustCompile(`.+-[0-9\.]+$`).FindString(projName) != ""
}

// setOutput set the given file as the output target, then all the output will be written to this file
func setOutput(fileName string) {
	configFile, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		log.Fatalf("Cannot create the configuration file %q: %v", fileName, err)
	}
	configFile.Truncate(0)
	configFile.Seek(0, 0)
	output = configFile
	tmplEval.OutFile = configFile
}

// main is the script entry point.
func main() {
	// Parse flags and sanity check them.
	prowConfigOutput := ""
	testgridConfigOutput := ""
	var generateProwConfig = flag.Bool("generate-prow-config", true, "Whether to generate the prow configuration file from the template")
	flag.StringVar(&prowConfigOutput, "prow-config-output", "", "The destination for the prow config output, default to be stdout")
	var generateTestgridConfig = flag.Bool("generate-testgrid-config", true, "Whether to generate the testgrid config from the template file")
	flag.StringVar(&testgridConfigOutput, "testgrid-config-output", "", "The destination for the testgrid config output, default to be stdout")

	var includeConfig = flag.Bool("include-config", true, "Whether to include general configuration (e.g., plank) in the generated config")
	flag.StringVar(&gcsBucket, "gcs-bucket", "knative-prow", "GCS bucket to upload the logs to")
	flag.StringVar(&logsDir, "logs-dir", "logs", "Path in the GCS bucket to upload logs of periodic and post-submit jobs")
	flag.StringVar(&presubmitLogsDir, "presubmit-logs-dir", "pr-logs", "Path in the GCS bucket to upload logs of pre-submit jobs")
	flag.StringVar(&testAccount, "test-account", "/etc/test-account/service-account.json", "Path to the service account JSON for test jobs")
	flag.StringVar(&nightlyAccount, "nightly-account", "/etc/nightly-account/service-account.json", "Path to the service account JSON for nightly release jobs")
	flag.StringVar(&releaseAccount, "release-account", "/etc/release-account/service-account.json", "Path to the service account JSON for release jobs")
	flag.StringVar(&flakesreporterDockerImage, "flaky-test-reporter-docker", "gcr.io/knative-tests/test-infra/flaky-test-reporter:latest", "Docker image for flaky test reporting tool")
	flag.StringVar(&prowversionbumperDockerImage, "prow-auto-bumper", "gcr.io/knative-tests/test-infra/prow-auto-bumper:latest", "Docker image for Prow version bumping tool")
	flag.StringVar(&coverageDockerImage, "coverage-docker", "gcr.io/knative-tests/test-infra/coverage:latest", "Docker image for coverage tool")
	flag.StringVar(&prowTestsDockerImage, "prow-tests-docker", "gcr.io/knative-tests/test-infra/prow-tests:stable", "prow-tests docker image")
	flag.StringVar(&githubCommenterDockerImage, "github-commenter-docker", "gcr.io/k8s-prow/commenter:v20190731-e3f7b9853", "github commenter docker image")
	flag.StringVar(&presubmitScript, "presubmit-script", "./test/presubmit-tests.sh", "Executable for running presubmit tests")
	flag.StringVar(&releaseScript, "release-script", "./hack/release.sh", "Executable for creating releases")
	flag.StringVar(&performanceScript, "performance-script", "./test/performance-tests.sh", "Executable for running performance tests")
	flag.StringVar(&webhookAPICoverageScript, "webhookAPICoverageScript", "./test/apicoverage.sh", "Executable for running webhook apicoverage tool")
	flag.StringVar(&cleanupScript, "cleanup-script", "./tools/cleanup/cleanup.sh", "Executable for running the cleanup tasks")
	flag.StringVar(&repositoryOverride, "repo-override", "", "Repository path (github.com/foo/bar[=branch]) to use instead for a job")
	flag.IntVar(&timeoutOverride, "timeout-override", 0, "Timeout (in minutes) to use instead for a job")
	flag.StringVar(&jobNameFilter, "job-filter", "", "Generate only this job, instead of all jobs")
	flag.StringVar(&preCommand, "pre-command", "", "Executable for running instead of the real command of a job")
	flag.Var(&extraEnvVars, "extra-env", "Extra environment variables (key=value) to add to a job")
	flag.Parse()
	if len(flag.Args()) != 1 {
		log.Fatal("Pass the config file as parameter")
	}
	// We use MapSlice instead of maps to keep key order and create predictable output.
	config := yaml.MapSlice{}

	// Read input config.
	name := flag.Arg(0)
	content, err := ioutil.ReadFile(name)
	if err != nil {
		log.Fatalf("Cannot read file %q: %v", name, err)
	}
	if err = yaml.Unmarshal(content, &config); err != nil {
		log.Fatalf("Cannot parse config %q: %v", name, err)
	}

	// Generate Prow config.
	if *generateProwConfig {
		output = os.Stdout
		if prowConfigOutput != "" {
			setOutput(prowConfigOutput)
		}
		repositories = make([]repositoryData, 0)
		sectionMap = make(map[string]bool)
		if *includeConfig {
			tmplEval.ExecuteTemplate("general config", readTemplate(generalProwConfig), newbaseProwJobTemplateData(""))
		}
		parseSection(config, "presubmits", generatePresubmit, nil)
		parseSection(config, "periodics", generatePeriodic, generateGoCoveragePeriodic)
		generateOtherJobConfigs("periodics", func(repo repositoryData) bool {
			return !repo.Processed && repo.EnableGoCoverage
		}, generateGoCoveragePeriodic)
		generateCleanupPeriodicJob()
		generateFlakytoolPeriodicJob()
		generateVersionBumpertoolPeriodicJob()
		generateBackupPeriodicJob()
		generateIssueTrackerPeriodicJobs()
		generateServingClusterUpdatePeriodicJobs()
		generateOtherJobConfigs("postsubmits", func(repo repositoryData) bool {
			return repo.EnableGoCoverage
		}, generateGoCoveragePostsubmit)
	}

	// config object is modified when we generate prow config, so we'll need to reload it here
	if err = yaml.Unmarshal(content, &config); err != nil {
		log.Fatalf("Cannot parse config %q: %v", name, err)
	}
	// Generate Testgrid config.
	if *generateTestgridConfig {
		output = os.Stdout
		if testgridConfigOutput != "" {
			setOutput(testgridConfigOutput)
		}

		if *includeConfig {
			tmplEval.ExecuteTemplate("general config", readTemplate(generalTestgridConfig), newBaseTestgridTemplateData(""))
		}

		presubmitJobData := parseJob(config, "presubmits")
		goCoverageMap = parseGoCoverageMap(presubmitJobData)

		periodicJobData := parseJob(config, "periodics")
		collectMetaData(periodicJobData)

		generateTestGridSection("test_groups", generateTestGroup, false)
		generateTestGridSection("dashboards", generateDashboard, true)
		generateDashboardsForReleases()
		generateDashboardGroups()
	}
}
